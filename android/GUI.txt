Activity 类中定义了七个回调方法,覆盖了活动生命周期的每一个环节,下面我来一一
介绍下这七个方法。
1. onCreate()
这个方法你已经看到过很多次了,每个活动中我们都重写了这个方法,它会在活动
第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作,比如说加载布
局、绑定事件等。
2. onStart()
这个方法在活动由不可见变为可见的时候调用。
3. onResume()
这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的
栈顶,并且处于运行状态。
4. onPause()
这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方
法中将一些消耗 CPU 的资源释放掉,以及保存一些关键数据,但这个方法的执行速度
一定要快,不然会影响到新的栈顶活动的使用。
5. onStop()
这个方法在活动完全不可见的时候调用。它和 onPause()方法的主要区别在于,如
果启动的新活动是一个对话框式的活动,那么 onPause()方法会得到执行,而 onStop()
方法并不会执行。
6. onDestroy()
这个方法在活动被销毁之前调用,之后活动的状态将变为销毁状态。
7. onRestart()
这个方法在活动由停止状态变为运行状态之前调用,也就是活动被重新启动了。
以上七个方法中除了 onRestart()方法,其他都是两两相对的,从而又可以将活动分为三
种生存期。
1. 完整生存期
活动在 onCreate()方法和 onDestroy()方法之间所经历的,就是完整生存期。一般情
况下,一个活动会在 onCreate()方法中完成各种初始化操作,而在 onDestroy()方法中完
成释放内存的操作。
2. 可见生存期
活动在 onStart()方法和 onStop()方法之间所经历的,就是可见生存期。在可见生存
期内,活动对于用户总是可见的,即便有可能无法和用户进行交互。我们可以通过这两
个方法,合理地管理那些对用户可见的资源。比如在 onStart()方法中对资源进行加载,
而在 onStop()方法中对资源进行释放,
从而保证处于停止状态的活动不会占用过多内存。
3. 前台生存期
活动在 onResume()方法和 onPause()方法之间所经历的,就是前台生存期。在前台
生存期内,活动总是处于运行状态的,此时的活动是可以和用户进行相互的,我们平时
看到和接触最多的也这个状态下的活动。

启动模式一共有四种,分别是 standard、singleTop、singleTask 和 singleInstance

//button onclicklistener
在 MainActivity 中为 Button 的点击事件注册一个监听器,如下所示:
public class MainActivity extends Activity {
private Button button;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
button = (Button) findViewById(R.id.button);
button.setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
// 在此处添加逻辑
}
});
}
}
这样每当点击按钮时,就会执行监听器中的 onClick()方法,我们只需要在这个方法中加
入待处理的逻辑就行了。如果你不喜欢使用匿名类的方式来注册监听器,也可以使用实现接
口的方式来进行注册,代码如下所示:
public class MainActivity extends Activity implements OnClickListener {
private Button button;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
button = (Button) findViewById(R.id.button);
button.setOnClickListener(this);
}
@Override
public void onClick(View v) {
switch (v.getId()) {
case R.id.button:
// 在此处添加逻辑
break;
default:
break;
}
}
}


//编写的每个活动都添加类似的启动方法
public class SecondActivity extends BaseActivity {
public static void actionStart(Context context, String data1, String data2) {
Intent intent = new Intent(context, SecondActivity.class);
intent.putExtra("param1", data1);
intent.putExtra("param2", data2);
context.startActivity(intent);
}
......
}
我们在 SecondActivity 中添加了一个 actionStart()方法,在这个方法中完成了 Intent 的构
建,另外所有 SecondActivity 中需要的数据都是通过 actionStart()方法的参数传递过来的,然
后把它们存储到 Intent 中,最后调用 startActivity()方法启动 SecondActivity。
这样写的好处在哪里呢?最重要的一点就是一目了然,SecondActivity 所需要的数据全
部都在方法参数中体现出来了,这样即使不用阅读 SecondActivity 中的代码,或者询问负责
编写 SecondActivity 的同事,你也可以非常清晰地知道启动 SecondActivity 需要传递哪些数
据。另外,这样写还简化了启动活动的代码,现在只需要一行代码就可以启动 SecondActivity,
如下所示:
button1.setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
SecondActivity.actionStart(FirstActivity.this, "data1", "data2");
}
});
养成一个良好的习惯,给你编写的每个活动都添加类似的启动方法,这样不仅可以让启
动活动变得非常简单,还可以节省不少你同事过来询问你的时间。

//注册一个监听器
在 MainActivity 中为 Button 的点击事件注册一个监听器,如下所示:
public class MainActivity extends Activity {
private Button button;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
button = (Button) findViewById(R.id.button);
button.setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
// 在此处添加逻辑
}
});
}
}
这样每当点击按钮时,就会执行监听器中的 onClick()方法,我们只需要在这个方法中加
入待处理的逻辑就行了。如果你不喜欢使用匿名类的方式来注册监听器,也可以使用实现接
口的方式来进行注册,代码如下所示:
public class MainActivity extends Activity implements OnClickListener {
private Button button;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
button = (Button) findViewById(R.id.button);
button.setOnClickListener(this);
}
@Override
public void onClick(View v) {
switch (v.getId()) {
case R.id.button:
90第 2 章
先从看得到的入手,探究活动
// 在此处添加逻辑
break;
default:
break;
}
}
}
这两种写法都可以实现对按钮点击事件的监听,至于使用哪一种就全凭你喜好了。

在编写 Android 程序的时候,尽量将控件或布局的大小指定成 match_parent
或 wrap_content,如果必须要指定一个固定值,则使用 dp 来作为单位,指定文字大小的时候
使用 sp 作为单位。

