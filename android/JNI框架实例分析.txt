JNI框架实例分析（Log系统)
涉及文件
frameworks/base/core/jni/android_util_Log.cpp (JNI层实现代码)
frameworks/base/core/jni/android_util_Log.h
frameworks/base/core/jni/AndroidRuntime.cpp
frameworks/base/core/java/android/Log.java (java层代码)
libnativehelper/include/nativehelper/jni.h (JNI规范的头文件)
libnativehelper/include/nativehelper/JNIHelper.h
libnativehelper/JNIHelp.cpp
Log.java中定义的native方法，java层自需要声明native无需实现
    public static native boolean isLoggable(String tag, int level);
    public static native int println_native(int bufID,
            int priority, String tag, String msg);
    private static native int logger_entry_max_payload_native();

Log系统的JNI层
JNI层是实现Java层方法最关键部分。
#include "jni.h"  //符合JNI规范的头文件，必须包含进来
#include "JNIHelper.h"  //Android为更好的支持JNI提供的头文件
#include "core_jni_helpers.h"  //对JNIHelper和AndroidRuntime的封装
system/core/liblog
JNI方法增加了JNIEnv和jobject两个参数，其余参数和返回值只是讲Java参数映射成JNI的数据类型，让后通过调用本地库(liblog)和JNIEnv提供的JNI函数处理数据，最后返回给Java层
static jboolean android_util_Log_isLoggable(JNIEnv* env, jobject clazz, jstring tag, jint level)
{
    if (tag == NULL) {
        return false;
    }
    //调用JNI函数，转换参数
    const char* chars = env->GetStringUTFChars(tag, NULL);
    if (!chars) {
        return false;
    }

    jboolean result = false;
    if ((strlen(chars)+sizeof(LOG_NAMESPACE)) > PROPERTY_KEY_MAX) {
        char buf2[200];
        snprintf(buf2, sizeof(buf2), "Log tag \"%s\" exceeds limit of %zu characters\n",
                chars, PROPERTY_KEY_MAX - sizeof(LOG_NAMESPACE));

        jniThrowException(env, "java/lang/IllegalArgumentException", buf2);
    } else {
        //jint不需要转换
        result = isLoggable(chars, level);
    }
    //调用JNI函数释放资源
    env->ReleaseStringUTFChars(tag, chars);
    return result;
}

static jint android_util_Log_println_native(JNIEnv* env, jobject clazz,
        jint bufID, jint priority, jstring tagObj, jstring msgObj)
{
    const char* tag = NULL;
    const char* msg = NULL;

    if (msgObj == NULL) {
        jniThrowNullPointerException(env, "println needs a message");
        return -1;
    }

    if (bufID < 0 || bufID >= LOG_ID_MAX) {
        jniThrowNullPointerException(env, "bad bufID");
        return -1;
    }

    if (tagObj != NULL)
        tag = env->GetStringUTFChars(tagObj, NULL);
    msg = env->GetStringUTFChars(msgObj, NULL);

    int res = __android_log_buf_write(bufID, (android_LogPriority)priority, tag, msg);

    if (tag != NULL)
        env->ReleaseStringUTFChars(tagObj, tag);
    env->ReleaseStringUTFChars(msgObj, msg);

    return res;
}

Log系统的JNI方法注册
//JNINativeMethod定义
typedef struct {
    const char* name;
    const char* signature;
    void*       fnPtr;
} JNINativeMethod;
//声明java和jni函数关联数组
static const JNINativeMethod gMethods[] = {
    /* name, signature, funcPtr */
    { "isLoggable",      "(Ljava/lang/String;I)Z", (void*) android_util_Log_isLoggable },
    { "println_native",  "(IILjava/lang/String;Ljava/lang/String;)I", (void*) android_util_Log_println_native },
    { "logger_entry_max_payload_native",  "()I", (void*) android_util_Log_logger_entry_max_payload_native },
};
JNINativeMethod中存储的信息对应关系
{ "isLoggable",      "(Ljava/lang/String;I)Z", (void*) android_util_Log_isLoggable }
Java层声明的Native函数名为isLoggable
Java层声明的Native函数的签名为(Ljava/lang/String;I)Z
JNI层实现方法的指针为(void*) android_util_Log_isLoggable
//注册  在AndroidRuntime::register_jni_procs中完成注册
int register_android_util_Log(JNIEnv* env)
{
    jclass clazz = FindClassOrDie(env, "android/util/Log");

    levels.verbose = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, "VERBOSE", "I"));
    levels.debug = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, "DEBUG", "I"));
    levels.info = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, "INFO", "I"));
    levels.warn = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, "WARN", "I"));
    levels.error = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, "ERROR", "I"));
    levels.assert = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, "ASSERT", "I"));

    return RegisterMethodsOrDie(env, "android/util/Log", gMethods, NELEM(gMethods));
}
//core_jni_helpers.h
static inline int RegisterMethodsOrDie(JNIEnv* env, const char* className,
                                       const JNINativeMethod* gMethods, int numMethods) {
    int res = AndroidRuntime::registerNativeMethods(env, className, gMethods, numMethods);
    LOG_ALWAYS_FATAL_IF(res < 0, "Unable to register native methods.");
    return res;
}
//AndroidRuntime.cpp
/*static*/ int AndroidRuntime::registerNativeMethods(JNIEnv* env,
    const char* className, const JNINativeMethod* gMethods, int numMethods)
{
    return jniRegisterNativeMethods(env, className, gMethods, numMethods);
}
//JNIHelper.cpp
extern "C" int jniRegisterNativeMethods(C_JNIEnv* env, const char* className,
    const JNINativeMethod* gMethods, int numMethods)
{
    JNIEnv* e = reinterpret_cast<JNIEnv*>(env);

    ALOGV("Registering %s's %d native methods...", className, numMethods);
    //找到Log类
    scoped_local_ref<jclass> c(env, findClass(env, className));
    if (c.get() == NULL) {
        ...
    }
    // 调用env完成注册本地方法，虚拟机就得到了Java层和JNI层之间的对应关系，接可以实现Java和C/C++代码的互操作
    if ((*env)->RegisterNatives(e, c.get(), gMethods, numMethods) < 0) {
        ...
    }

    return 0;
}
使用JNI有两种方式：一种是遵守JNI规范的函数命名规范，建立声明函数和实现函数之间的对应关系；另一种就是Log系统采用的函数注册方式。应用层多采用第一种方式，应用框架层多采用第二种方式。

Java数据类型与JNI数据类型转换
基本类型
boolean byte char short int long float double 前面都加j
void 还是void
引用类型
java.lang.Class    jclass
java.lang.String    jstring
java.lang.Throwable    jthrowable
java.lang.Object    jobject
Object[]      boolean[]      byte[] char[] short[] int[] long[] float[] double[]
jobjectArray  jbooleanArray  ......

JNI方法命名规则
JNI方法第一个参数是JNIEnv指针，第二个参数因本地方法是静态还是非静态而有所不同。非静态本地方法的第二个参数是对Java对象的引用，而静态本地方法是对其Java类的引用。其余参数对应Java方法的参数按类型映射。
JNI方法签名规则
(参数1类型签名参数2类型签名...)返回值类型签名
以上签名字符串之间均没有空格
Java类型    类型签名
boolean      Z
byte         B
char         C
double       D
float        F
int          I
long         J
short        S
类           L全限定类名;
数组         [元素类型签名
java 方法：
long func(int n, String str, int[] arr);
(ILjava/lang/String;[I)J

Jni访问Java对象
JNI方法接受的第二个参数是Java对象：jobject，可以在JNI中操作这个jobject进而操作Java对象提供的变量和方法
JNI方法提供的常用操作对象函数：
jclass FindClass(const char* name);
jclass GetObjectClass(jobject obj);
JNI操作域和方法的函数 //jni.h
访问对象的域                 调用实例方法
GetFieldID                   GetMethodID
Get(Byte|Char|...)Field      Call(Byte|...)Method
Set<Type>Field               CallNonvirtual<Type>Method
访问静态域                   调用静态方法
GetStaticFieldID             GetStaticMethodID
GetStatid<Type>Field         CallStatic<Type>Method
SetStatic<Type>Field

JNI中的全局引用、弱全局引用和局部引用
全局引用，可增加引用计数。作用范围为多线程，多个Native方法，生命周期到显示释放。不释放不回收，对于全局引用默认不能超过2000个，如果在Dalvik启动参数dalvik.vm.checkjni中打开checkjni选项，Dalvik讲监控全局变量引用数量，超过2000个会看到"GREF overflow".
    jobject NewGlobalRef(jobject obj)
    void DeleteGlobalRef(jobject globalRef)
弱全局引用，不增加引用计数。作用范围为多线程，多个Native方法，生命周期到显示释放。优点是：既可保存对象，又不会应该虚拟机对该对象的回收。使用时需要用IsSameObject判断该对象是否被回收。
if (env->IsSameObject(weak_gref, NULL) == JNI_TRUE)
    // 该对象已被回收
    jweak NewWeakGlobalRef(jobject obj)
    void DeleteWeakGlobalRef(jweak obj)
    jboolean IsSameObject(jobject ref1, jobject ref2)
局部引用，可以增加引用计数，作用范围为本线程，生命周期为一次Native调用。
    void DeleteLocalRef(jobject localRef)
    jobject NewLocalRef(jobject ref)

JNI异常处理
其处理机制与Java和C++都不一样。JNI提供了两种检查异常的方法：
1.检查上一次JNI函数调用的返回值是否为NULL。
2.通过调用JNI函数ExceptionOccurred()来判断是否发生异常。
处理异常的方法：
1.Native方法可以选择立即返回。这样异常就会在调用该Native方法的Java代码中抛出。所以在Java代码中必须有捕获相应异常的代码，否则程序直接退出。
2.Native方法可以调用ExceptionClear()来清除异常，然后执行自己的异常处理代码。
JNI提供的检查和处理异常的函数如下：
Throw  抛出现有异常
ThrowNew  抛出新的异常
ExceptionOccurred  判断是否发生异常并获得异常的引用
ExceptionCheck  判断是否发生异常
ExceptionDescribe  异常堆栈信息
ExceptionClear  清除一个未处理的异常
FatalError  严重错误，退出
异常出现后，Native代码必须先检查清除异常，然后才能进行其他JNI函数调用。当有异常未被清除时，只有以下JNI异常处理函数可被安全的调用：
ExceptionOccurred  判断是否发生异常并获得异常的引用
ExceptionCheck  判断是否发生异常
ExceptionDescribe  异常堆栈信息
ExceptionClear  清除一个未处理的异常

extern "C" int jniThrowException(C_JNIEnv* env, const char* className, const char* msg) {
    JNIEnv* e = reinterpret_cast<JNIEnv*>(env);
    //抛出异常前先检查是否有异常未被处理，如果有先释放掉
    if ((*env)->ExceptionCheck(e)) {
        /* TODO: consider creating the new exception with this as "cause" */
        scoped_local_ref<jthrowable> exception(env, (*env)->ExceptionOccurred(e));
        (*env)->ExceptionClear(e);

        if (exception.get() != NULL) {
            std::string text;
            getExceptionSummary(env, exception.get(), text);
            ALOGW("Discarding pending exception (%s) to throw %s", text.c_str(), className);
        }
    }

    scoped_local_ref<jclass> exceptionClass(env, findClass(env, className));
    if (exceptionClass.get() == NULL) {
        ALOGE("Unable to find exception class %s", className);
        /* ClassNotFoundException now pending */
        return -1;
    }
    //然后再抛出新异常
    if ((*env)->ThrowNew(e, exceptionClass.get(), msg) != JNI_OK) {
        ALOGE("Failed throwing '%s' '%s'", className, msg);
        /* an exception, most likely OOM, will now be pending */
        return -1;
    }

    return 0;
}



